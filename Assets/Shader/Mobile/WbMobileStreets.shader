//-----------------------------------------------------------------
//
//	@brief		Mobile Street Shader
//
//	@author		Benedikt Niesen (benedikt@weltenbauer-se.com)
//
//	@date		June 2013
//
//-----------------------------------------------------------------
//
// Shader for Streets in BauSimulator 2014 iOS Version. 2 Main Textures with 
// different StreetTypes computed in Shader to Street Look based on Vertex 
// Colors. Lightmap UV's are generated by WorldPosition
//
//-----------------------------------------------------------------

Shader "WbMobileShader/WbMobileStreets" {
	
//-----------------------------------------------------------------
// Properties
//-----------------------------------------------------------------
	
	Properties {
		
		// - Color
		_MainColor ("Diffuse Color", Color) = (1,1,1,1)
		
		// - Textures
		_MainTex ("Main Texture 1", 2D) = "white" {}
		_MainTex2 ("Main Texture 2", 2D) = "white" {}
		_SandTex ("Sand Texture", 2D) = "white" {}
		_SplatMap ("Terrain SplatMap", 2D) = "white" {}
		_LightTex ("Lightmap", 2D) = "white" {}
	}

//-----------------------------------------------------------------
// SubShader
//-----------------------------------------------------------------

	SubShader {
	
	//-----------------------------------------------------------------
	// SubShader Tags

		Tags {	"Queue"="Geometry"
				"RenderType"="Opaque"
				"IgnoreProjector"="True"
				"ForceNoShadowCasting"="True"
				"LightMode"="ForwardBase" }
				// Possible to set LightMode to : Vertex
				
		LOD 250 // Maybe different LODs for different Devices, can be set in Script
		
	//-----------------------------------------------------------------
	// First Pass
	//-----------------------------------------------------------------
		
		Pass {
		
		//-----------------------------------------------------------------
		// Per Pass Tags and Lighting, Cull, ...
			
			Tags {} 
			Lighting On
			Fog { Mode Off }
			ZWrite On
			
		//-----------------------------------------------------------------
		// CG Program with renderer excludes
			
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			#pragma fragmentoption ARB_precision_hint_fastest
			#pragma glsl_no_auto_normalization
			
		//-----------------------------------------------------------------
		// Render Targets
			
			// - For development use this line
			#pragma exclude_renderers xbox360 ps3 d3d11 d3d11_9x flash glesdesktop
			
			// - For final Build use this line
			//#pragma only_renderers gles
			
		//-----------------------------------------------------------------
		// Multi Compile for different Plattforms
			
			#pragma multi_compile NO_LIGHTMAP IS_LIGHTMAP
			#pragma multi_compile IS_WEAK IS_STRONG
//			#pragma multi_compile PREFER_HALF_PRECISION PREFER_FIXED_PRECISION
//			#ifdef PREFER_HALF_PRECISION
//				// force all operations to higher precision
//				#define scalar half
//				#define vec4 half4
//			#else
//				#define scalar fixed
//				#define vec4 fixed4
//			#endif


		//-----------------------------------------------------------------
		// CG Includes
			
			#include "WbShaderInclude.cginc"
			
		//-----------------------------------------------------------------
		// INPUTS

			// Color Inputs
			uniform fixed4 _MainColor;
						
			// Texture Inputs
			uniform sampler2D _MainTex;
			uniform sampler2D _MainTex2;
			
			uniform sampler2D _SandTex;

			uniform sampler2D _SplatMap;
			uniform sampler2D _LightTex;
			
			// Texture to UV Inputs
			
			// Control Inputs

	//-----------------------------------------------------------------
	// Structs
	//-----------------------------------------------------------------
			
		//-----------------------------------------------------------------
		// App To Vertex Struct
										
			struct a2v {
			
				float4 vertex	: POSITION; // Vertex Position
				fixed3 normal	: NORMAL; // Vertex Normal
				half2 texcoord	: TEXCOORD0; // UV Set
				half2 texcoord1	: TEXCOORD1; // UV Set
				fixed4 color	: COLOR; // Vertex Color
			};
			
		//-----------------------------------------------------------------
		// Vertex to Fragment Struct
			
			struct v2f {
			
				float4 pos			: POSITION;
				half2 uv1			: TEXCOORD0; // UV Set for Street Textures
				half2 uv2			: TEXCOORD1; // UV Set for SplatMap + Lightmap
				half2 uv3			: TEXCOORD2; // UV Set for tilable SplatTextures
				half2 uv4			: TEXCOORD3; // UV Set for tilable SplatTextures
				fixed3 vertexlight	: TEXCOORD4;
				fixed2 stripeamount	: TEXCOORD5;
				fixed3 marksamount	: TEXCOORD6;	
			};
			
	//-----------------------------------------------------------------
	// Shader
	//-----------------------------------------------------------------
			
		//-----------------------------------------------------------------
		// Vertex Shader
			
			v2f vert (a2v v) {
			
				v2f output;
		        
		        // - Output Position
		        output.pos = mul(UNITY_MATRIX_MVP, v.vertex);
			
				// - Output UV Coordinates
				output.uv1 = v.texcoord.xy;
				output.uv2 = WorldUvTop(v.vertex, 1500.0);
				output.uv3 = v.texcoord1.xy;
				output.uv4 = v.texcoord1.xy * 0.5;
				// - Output Vertex Light
				#if defined(IS_STRONG)
					output.vertexlight = _MainColor * VertexLight(v.normal);
				#endif
				#if defined(IS_WEAK)
					output.vertexlight = VertexLight(v.normal);
				#endif
								
				// - Compute Stripes and Marks
				// - Set initial value to 0
				output.stripeamount.xy = 0.0;

				#if defined(IS_STRONG)
					output.marksamount.xyz = fixed3(0.0, 0.0, v.color.b) ;
				#endif
				#if defined(IS_WEAK)
					//output.marksamount.xyz = fixed3(0.0, 0.0, v.color.b) ;
				#endif				
				
			
				// - Stripes
				if (v.color.r < 0.34) {
					// Set middle Stripe
					output.stripeamount.x = 3.0 * (v.color.r);
				}
				else if (v.color.r < 0.67) { 
					// Set outer Stripe
					output.stripeamount.y = 3.0 * (v.color.r - 0.34);	// It is a little bit faster to first
																		// multiply, then do the substraction
				}						
				else if (v.color.r < 1.01) {
					// Set both Stripes
					output.stripeamount.xy = 3.0 * (v.color.r - 0.67); 
				};
				
				#if defined(IS_STRONG)
					// - Marks
					if (v.color.g < 0.51) {
						output.marksamount.y = 2.0 * (v.color.g);
					}
					else if (v.color.g < 1.1) { 
						output.marksamount.x = 2.0 * (v.color.g - 0.5);
					};
				#endif

				// - Return to Fragment Shader
				return output;
			};
			
		//-----------------------------------------------------------------
		// Fragment Shader
				
			fixed4 frag (v2f input) : COLOR	{
			
				// - Read Textures
				fixed tex0 = tex2D (_MainTex, input.uv4).r;
				fixed3 tex1 = tex2D (_MainTex, input.uv1).rgb;
				fixed3 tex2 = tex2D (_MainTex2, input.uv1).rgb;
				
				fixed4 splatmap = tex2D (_SplatMap, input.uv2);
				
				fixed3 sand = tex2D (_SandTex, input.uv3).rgb;
				
				// - Define Variables
				fixed4 c; 
                
				fixed concrete;
				fixed stripes;
				fixed marks;
				fixed cracks;
				fixed3 finalcolor; 
				
				// - Compute Stuff
				
				// - Compute Stripe Amount
				stripes = (tex2.r * (input.stripeamount.r)) + (tex2.g * (input.stripeamount.g));

				#if defined(IS_STRONG)
					// - Compute Mark Amount
					marks = tex1.g * input.marksamount.r + tex1.b * input.marksamount.g ;
					// - Compute Cracks				
					cracks = lerp(1, tex2.b, input.marksamount.b);
				#endif

// OLD Textures	START							
//				// - Compute Stripe Amount
//				stripes = (tex1.g * (input.stripeamount.r)) + (tex1.b * (input.stripeamount.g));
//				// - Compute Mark Amount
//				marks = tex2.r * input.marksamount.r + tex2.g * input.marksamount.g ;
//				// - Compute Cracks
//				cracks = lerp(1, tex2.b, input.marksamount.b);
// OLD Textures	END
				
				// - Compute Concrete
				#if defined(IS_STRONG)				
					concrete = (tex0 + stripes - marks) * cracks;	
				#endif
				#if defined(IS_WEAK)				
					concrete = (tex0 + stripes);	
				#endif				
				// - Compute Final Color
				finalcolor = ((concrete * splatmap.r) + sand * (splatmap.b + splatmap.a)) * input.vertexlight.rgb;
						
				// - Output
                c.rgb = finalcolor;
                
                #if defined(IS_LIGHTMAP)
					c.rgb *= DecodeLightMap(tex2D(_LightTex, input.uv2));
				#endif
				
				c.a = 1.0;
				
				return c;
			};
			
			ENDCG 
			
		} // Pass End
		
	} // SubShader End
	
	//Commented out during Development
	//Fallback "Mobile/VertexLit" 
	
} // Shader End